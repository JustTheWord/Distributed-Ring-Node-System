// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package ringnode

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RingNodeClient is the client API for RingNode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RingNodeClient interface {
	// Ring membership
	InformSuccessor(ctx context.Context, in *NeighborInfo, opts ...grpc.CallOption) (*Ack, error)
	InformPredecessor(ctx context.Context, in *NeighborInfo, opts ...grpc.CallOption) (*Ack, error)
	// Snapshot
	SendMarker(ctx context.Context, in *MarkerMessage, opts ...grpc.CallOption) (*Ack, error)
	SendRecordedState(ctx context.Context, in *RecordedState, opts ...grpc.CallOption) (*Ack, error)
	SendData(ctx context.Context, in *DataMessage, opts ...grpc.CallOption) (*Ack, error)
	// Mutual Exclusion
	RequestAccess(ctx context.Context, in *MutualExclusionRequest, opts ...grpc.CallOption) (*MutualExclusionResponse, error)
	ReleaseAccess(ctx context.Context, in *MutualExclusionRelease, opts ...grpc.CallOption) (*Ack, error)
}

type ringNodeClient struct {
	cc grpc.ClientConnInterface
}

func NewRingNodeClient(cc grpc.ClientConnInterface) RingNodeClient {
	return &ringNodeClient{cc}
}

func (c *ringNodeClient) InformSuccessor(ctx context.Context, in *NeighborInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/InformSuccessor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ringNodeClient) InformPredecessor(ctx context.Context, in *NeighborInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/InformPredecessor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ringNodeClient) SendMarker(ctx context.Context, in *MarkerMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/SendMarker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ringNodeClient) SendRecordedState(ctx context.Context, in *RecordedState, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/SendRecordedState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ringNodeClient) SendData(ctx context.Context, in *DataMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/SendData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ringNodeClient) RequestAccess(ctx context.Context, in *MutualExclusionRequest, opts ...grpc.CallOption) (*MutualExclusionResponse, error) {
	out := new(MutualExclusionResponse)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/RequestAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ringNodeClient) ReleaseAccess(ctx context.Context, in *MutualExclusionRelease, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/ringnode.RingNode/ReleaseAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RingNodeServer is the server API for RingNode service.
// All implementations must embed UnimplementedRingNodeServer
// for forward compatibility
type RingNodeServer interface {
	// Ring membership
	InformSuccessor(context.Context, *NeighborInfo) (*Ack, error)
	InformPredecessor(context.Context, *NeighborInfo) (*Ack, error)
	// Snapshot
	SendMarker(context.Context, *MarkerMessage) (*Ack, error)
	SendRecordedState(context.Context, *RecordedState) (*Ack, error)
	SendData(context.Context, *DataMessage) (*Ack, error)
	// Mutual Exclusion
	RequestAccess(context.Context, *MutualExclusionRequest) (*MutualExclusionResponse, error)
	ReleaseAccess(context.Context, *MutualExclusionRelease) (*Ack, error)
	mustEmbedUnimplementedRingNodeServer()
}

// UnimplementedRingNodeServer must be embedded to have forward compatible implementations.
type UnimplementedRingNodeServer struct {
}

func (UnimplementedRingNodeServer) InformSuccessor(context.Context, *NeighborInfo) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InformSuccessor not implemented")
}
func (UnimplementedRingNodeServer) InformPredecessor(context.Context, *NeighborInfo) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InformPredecessor not implemented")
}
func (UnimplementedRingNodeServer) SendMarker(context.Context, *MarkerMessage) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMarker not implemented")
}
func (UnimplementedRingNodeServer) SendRecordedState(context.Context, *RecordedState) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRecordedState not implemented")
}
func (UnimplementedRingNodeServer) SendData(context.Context, *DataMessage) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendData not implemented")
}
func (UnimplementedRingNodeServer) RequestAccess(context.Context, *MutualExclusionRequest) (*MutualExclusionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestAccess not implemented")
}
func (UnimplementedRingNodeServer) ReleaseAccess(context.Context, *MutualExclusionRelease) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseAccess not implemented")
}
func (UnimplementedRingNodeServer) mustEmbedUnimplementedRingNodeServer() {}

// UnsafeRingNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RingNodeServer will
// result in compilation errors.
type UnsafeRingNodeServer interface {
	mustEmbedUnimplementedRingNodeServer()
}

func RegisterRingNodeServer(s grpc.ServiceRegistrar, srv RingNodeServer) {
	s.RegisterService(&RingNode_ServiceDesc, srv)
}

func _RingNode_InformSuccessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NeighborInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).InformSuccessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/InformSuccessor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).InformSuccessor(ctx, req.(*NeighborInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RingNode_InformPredecessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NeighborInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).InformPredecessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/InformPredecessor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).InformPredecessor(ctx, req.(*NeighborInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RingNode_SendMarker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkerMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).SendMarker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/SendMarker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).SendMarker(ctx, req.(*MarkerMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _RingNode_SendRecordedState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordedState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).SendRecordedState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/SendRecordedState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).SendRecordedState(ctx, req.(*RecordedState))
	}
	return interceptor(ctx, in, info, handler)
}

func _RingNode_SendData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).SendData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/SendData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).SendData(ctx, req.(*DataMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _RingNode_RequestAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MutualExclusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).RequestAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/RequestAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).RequestAccess(ctx, req.(*MutualExclusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RingNode_ReleaseAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MutualExclusionRelease)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RingNodeServer).ReleaseAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ringnode.RingNode/ReleaseAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RingNodeServer).ReleaseAccess(ctx, req.(*MutualExclusionRelease))
	}
	return interceptor(ctx, in, info, handler)
}

// RingNode_ServiceDesc is the grpc.ServiceDesc for RingNode service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RingNode_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ringnode.RingNode",
	HandlerType: (*RingNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InformSuccessor",
			Handler:    _RingNode_InformSuccessor_Handler,
		},
		{
			MethodName: "InformPredecessor",
			Handler:    _RingNode_InformPredecessor_Handler,
		},
		{
			MethodName: "SendMarker",
			Handler:    _RingNode_SendMarker_Handler,
		},
		{
			MethodName: "SendRecordedState",
			Handler:    _RingNode_SendRecordedState_Handler,
		},
		{
			MethodName: "SendData",
			Handler:    _RingNode_SendData_Handler,
		},
		{
			MethodName: "RequestAccess",
			Handler:    _RingNode_RequestAccess_Handler,
		},
		{
			MethodName: "ReleaseAccess",
			Handler:    _RingNode_ReleaseAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/ringnode/ringnode.proto",
}
